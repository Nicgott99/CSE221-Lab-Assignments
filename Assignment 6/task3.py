# -*- coding: utf-8 -*-
"""task3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18s8CFoacQxYml6eCr3qCqVKaDfSC_sUU
"""

#Name: Md Hasib Ullah Khan Alvie
#Section: 23
#Student ID: 22101371

import heapq

def dijkstra(graph, source, destination):
    max_danger = [float('inf')] * len(graph)
    max_danger[source - 1] = 0

    pq = [(0, source)]

    while pq:
        danger, node = heapq.heappop(pq)

        if danger > max_danger[node - 1]:
            continue

        if node == destination:
            return max_danger[node - 1]

        for neighbor, edge_danger in graph[node]:
            new_danger = max(danger, edge_danger)
            if new_danger < max_danger[neighbor - 1]:
                max_danger[neighbor - 1] = new_danger
                heapq.heappush(pq, (new_danger, neighbor))

    return -1

# Read input
input_file = open("input3.txt", "r")
output_file = open("output3.txt", "w")

num_nodes, num_edges = map(int, input_file.readline().split())
graph = [[] for _ in range(num_nodes + 1)]

for _ in range(num_edges):
    u, v, w = map(int, input_file.readline().split())
    graph[u].append((v, w))

destination = num_nodes

# Run Dijkstra's algorithm
min_max_danger = dijkstra(graph, 1, destination)

# Output the result
if min_max_danger == -1:
    output_file.write("Impossible\n")
else:
    output_file.write(str(min_max_danger) + "\n")

input_file.close()
output_file.close()

